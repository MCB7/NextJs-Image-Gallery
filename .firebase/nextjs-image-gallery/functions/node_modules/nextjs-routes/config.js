import { getAppDirectory, getPagesDirectory } from "./utils.js";
import { watch } from "chokidar";
import { logger, writeNextjsRoutes } from "./core.js";
function debounce(fn, ms) {
    let id;
    return function (...args) {
        clearTimeout(id);
        id = setTimeout(() => fn(...args), ms);
    };
}
class NextJSRoutesPlugin {
    constructor(config, options) {
        this.config = config;
        this.options = options;
    }
    apply() {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        const cwd = this.options?.cwd ?? process.cwd();
        const watchDirs = [getPagesDirectory(cwd), getAppDirectory(cwd)].filter((x) => x != undefined);
        if (watchDirs.length > 0) {
            const options = {
                ...this.config,
                ...this.options,
            };
            if (this.options.watch) {
                const watcher = watch(watchDirs, {
                    persistent: true,
                });
                // batch changes
                const generate = debounce(() => writeNextjsRoutes(options), 50);
                watcher.on("add", generate).on("unlink", generate);
            }
            else {
                writeNextjsRoutes(options);
            }
        }
        else {
            logger.error(`Could not find a Next.js pages directory. Expected to find either 'pages' (1), 'src/pages' (2), or 'app' (3) in your project root.

  1. https://nextjs.org/docs/basic-features/pages
  2. https://nextjs.org/docs/advanced-features/src-directory
  3. https://nextjs.org/blog/next-13#app-directory-beta
  `);
        }
    }
}
export default function withRoutes(options) {
    return function (nextConfig) {
        return {
            ...nextConfig,
            webpack: (config, context) => {
                if (!config.plugins) {
                    config.plugins = [];
                }
                config.plugins.push(new NextJSRoutesPlugin(nextConfig, {
                    // only watch in development
                    watch: context.dev && !context.isServer,
                    ...options,
                }));
                // invoke any existing webpack extensions
                if (nextConfig.webpack) {
                    return nextConfig.webpack(config, context);
                }
                return config;
            },
        };
    };
}
