import { existsSync, mkdirSync, writeFileSync } from "fs";
import { join, parse, sep } from "path";
import { findFiles, getAppDirectory, getPagesDirectory } from "./utils.js";
function convertWindowsPathToUnix(file) {
    return file.replace(/\\/g, "/");
}
export function nextRoutes(pathnames) {
    const DYNAMIC_SEGMENT_RE = /\[(.*?)\]/g;
    return pathnames.map((pathname) => {
        const segments = pathname.match(DYNAMIC_SEGMENT_RE) ?? [];
        const query = segments.reduce((acc, cur) => {
            const param = cur
                .replace(/\[/g, "")
                .replace(/\]/g, "")
                .replace("...", "");
            let queryType = "dynamic";
            if (cur.startsWith("[[")) {
                queryType = "optional-catch-all";
            }
            else if (cur.startsWith("[...")) {
                queryType = "catch-all";
            }
            acc[param] = queryType;
            return acc;
        }, {});
        return {
            pathname,
            query,
        };
    });
}
function getQueryInterface(query) {
    let requiredKeys = 0;
    const keys = Object.entries(query)
        .map(([key, value]) => {
        switch (value) {
            case "dynamic": {
                requiredKeys += 1;
                return `"${key}": string`;
            }
            case "catch-all": {
                requiredKeys += 1;
                return `"${key}": string[]`;
            }
            case "optional-catch-all": {
                return `"${key}"?: string[] | undefined`;
            }
            // istanbul ignore next
            default: {
                const _exhaust = value;
                return _exhaust;
            }
        }
    })
        .join("; ");
    return [`{ ${keys} }`, requiredKeys];
}
function generate(routes, config) {
    const i18n = config.i18n ?? {
        defaultLocale: "",
        domains: [],
        localeDetection: false,
        locales: [],
    };
    return `\
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// This file will be automatically regenerated when your Next.js server is running.
/* eslint-disable */

// prettier-ignore
declare module "nextjs-routes" {
  export type Route =
    ${!routes.length
        ? "never"
        : `| ${routes
            .map((route) => {
            const [params, requiredKeys] = getQueryInterface(route.query);
            return requiredKeys > 0
                ? `DynamicRoute<"${route.pathname}", ${params}>`
                : `StaticRoute<"${route.pathname}">`;
        })
            .join("\n    | ")}`};

  interface StaticRoute<Pathname> {
    pathname: Pathname;
    query?: Query | undefined;
    hash?: string | null | undefined;
  }

  interface DynamicRoute<Pathname, Parameters> {
    pathname: Pathname;
    query: Parameters & Query;
    hash?: string | null | undefined;
  }

  interface Query {
    [key: string]: string | string[] | undefined;
  };

  export type RoutedQuery<P extends Route["pathname"]> = Extract<
    Route,
    { pathname: P }
  >["query"];

  export type Locale = ${!i18n.locales.length
        ? "undefined"
        : `\n    | ${i18n.locales.map((x) => `"${x}"`).join("\n    | ")}`};

  /**
   * A typesafe utility function for generating paths in your application.
   *
   * route({ pathname: "/foos/[foo]", query: { foo: "bar" }}) will produce "/foos/bar".
   */
  export declare function route(r: Route): string;
}

// prettier-ignore
declare module "next/link" {
  import type { Route } from "nextjs-routes";
  import type { LinkProps as NextLinkProps } from "next/dist/client/link";
  import type {
    AnchorHTMLAttributes,
    DetailedReactHTMLElement,
    MouseEventHandler,
    PropsWithChildren,
  } from "react";
  export * from "next/dist/client/link";

  type Query = { query?: { [key: string]: string | string[] | undefined } };
  type StaticRoute = Exclude<Route, { query: any }>["pathname"];

  export interface LinkProps<
    Href extends Route | StaticRoute | Query = Route | StaticRoute | Query
  >
    extends Omit<NextLinkProps, "href" | "locale">,
      AnchorHTMLAttributes<HTMLAnchorElement> {
    href: Href;
    locale?: ${!i18n.locales.length ? "false" : `Locale | false`};
  }

  type LinkReactElement = DetailedReactHTMLElement<
    {
      onMouseEnter?: MouseEventHandler<Element> | undefined;
      onClick: MouseEventHandler;
      href?: string | undefined;
      ref?: any;
    },
    HTMLElement
  >;

  declare function Link(
    props: PropsWithChildren<LinkProps<Route>>
  ): LinkReactElement;
  declare function Link(
    props: PropsWithChildren<LinkProps<StaticRoute>>
  ): LinkReactElement;
  declare function Link(
    props: PropsWithChildren<LinkProps<Query>>
  ): LinkReactElement;

  export default Link;
}

// prettier-ignore
declare module "next/router" {
  import type { Locale, Route, RoutedQuery } from "nextjs-routes";
  import type { NextRouter as Router } from "next/dist/client/router";
  export * from "next/dist/client/router";
  export { default } from "next/dist/client/router";

  type NextTransitionOptions = NonNullable<Parameters<Router["push"]>[2]>;
  type StaticRoute = Exclude<Route, { query: any }>["pathname"];

  interface TransitionOptions extends Omit<NextTransitionOptions, "locale"> {
    locale?: ${!i18n.locales.length ? "false" : `Locale | false`};
  }

  export type NextRouter<P extends Route["pathname"] = Route["pathname"]> =
    Extract<Route, { pathname: P }> &
      Omit<
        Router,
        | "push"
        | "replace"
        | "locale"
        | "locales"
        | "defaultLocale"
        | "domainLocales"
      > & {
        defaultLocale${i18n.defaultLocale ? `: "${i18n.defaultLocale}"` : "?: undefined"};
        domainLocales${i18n.domains?.length ? `: ${print(i18n.domains, 8)}` : "?: undefined"};
        locale${!i18n.locales.length ? "?:" : ":"} Locale;
        locales${i18n.locales.length ? `: ${print(i18n.locales, 8)}` : "?: undefined"};
        push(
          url: Route,
          as?: string,
          options?: TransitionOptions
        ): Promise<boolean>;
        push(
          url: StaticRoute,
          as?: string,
          options?: TransitionOptions
        ): Promise<boolean>;
        push(
          url: { query?: { [key: string]: string | string[] | undefined } },
          as?: string,
          options?: TransitionOptions
        ): Promise<boolean>;
        replace(
          url: Route,
          as?: string,
          options?: TransitionOptions
        ): Promise<boolean>;
        replace(
          url: StaticRoute,
          as?: string,
          options?: TransitionOptions
        ): Promise<boolean>;
        replace(
          url: { query?: { [key: string]: string | string[] | undefined } },
          as?: string,
          options?: TransitionOptions
        ): Promise<boolean>;
        route: P;
      };

  export function useRouter<P extends Route["pathname"]>(): NextRouter<P>;
}
`;
}
function print(x, indent) {
    return JSON.stringify(x, undefined, 2)
        .split("\n")
        .join("\n" + " ".repeat(indent));
}
export const logger = {
    error: (str) => console.error("[nextjs-routes] " + str),
};
function commonProcessing(paths, opts) {
    return (paths
        // filter page extensions
        .filter((file) => {
        return opts.pageExtensions.some((ext) => file.endsWith(ext));
    })
        // remove file extensions (.tsx, .test.tsx)
        .map((file) => file.replace(/(\.\w+)+$/, ""))
        // remove duplicates from file extension removal (eg foo.ts and foo.test.ts)
        .filter((file, idx, array) => array.indexOf(file) === idx)
        // remove page directory path
        .map((file) => file.replace(opts.directory, ""))
        // normalize paths from windows users
        .map(convertWindowsPathToUnix));
}
export function getAppRoutes(files, opts) {
    return (commonProcessing(files, opts)
        // app pages must be named 'page'
        .filter((file) => parse(file).name === "page")
        .map((file) => 
    // transform filepath to url path
    file
        .split(sep)
        // remove named groups
        .filter((segment) => !(segment.startsWith("(") && segment.endsWith(")")))
        // remove page
        .filter((file) => parse(file).name !== "page")
        .join(sep)));
}
export function getPageRoutes(files, opts) {
    const NEXTJS_NON_ROUTABLE = ["/_app", "/_document", "/_error", "/middleware"];
    return (commonProcessing(files, opts)
        // remove index if present (/foos/index.ts is the same as /foos.ts)
        .map((file) => file.replace(/index$/, ""))
        // remove trailing slash if present
        .map((file) => file.endsWith("/") && file.length > 2 ? file.slice(0, -1) : file)
        // exclude nextjs special routes
        .filter((file) => !NEXTJS_NON_ROUTABLE.includes(file)));
}
export function writeNextjsRoutes(options) {
    const defaultOptions = {
        dir: process.cwd(),
        outDir: "",
        pageExtensions: ["tsx", "ts", "jsx", "js"],
    };
    const opts = {
        ...defaultOptions,
        ...options,
    };
    const files = [];
    const pagesDirectory = getPagesDirectory(opts.dir);
    if (pagesDirectory) {
        const routes = getPageRoutes(findFiles(pagesDirectory), {
            pageExtensions: opts.pageExtensions,
            directory: pagesDirectory,
        });
        files.push(...routes);
    }
    const appDirectory = getAppDirectory(opts.dir);
    if (appDirectory) {
        const routes = getAppRoutes(findFiles(appDirectory), {
            pageExtensions: opts.pageExtensions,
            directory: appDirectory,
        });
        files.push(...routes);
    }
    const outputFilepath = join(opts.outDir, "nextjs-routes.d.ts");
    if (opts.outDir && !existsSync(opts.outDir)) {
        mkdirSync(opts.outDir, { recursive: true });
    }
    const routes = nextRoutes(files);
    const generated = generate(routes, opts);
    writeFileSync(outputFilepath, generated);
}
